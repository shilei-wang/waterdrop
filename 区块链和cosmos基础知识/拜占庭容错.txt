拜占庭的n个将军围攻一个敌人，n个将军包围着这个敌人，所以他们是在不同的地方。忠诚的将军希望通过某种协议达成某个命令的一致（比如约定某个时间一起进攻）。但其中一些背叛的将军会通过发送错误的消息阻挠忠诚的将军达成命令上的一致。如果同时发起进攻的将军数量少于m个，那么不足以歼灭敌人反而容易被敌人全部歼灭。怎样做才能保证有多于m个将军在同一时间一起发起进攻？

“拜占庭将军问题”模型中，对于将军们（节点）有两个默认的假设： 

所有忠诚的将军收到相同的命令后，执行这条命令得到的结果一定是相同的；

如果命令是正确的，那么所有忠诚的将军必须执行这条命令。

假设1的含义是：所有节点对命令的解析和执行是一样的，这个命令必须是一个确定性的命令，不能存在随机性，也不能依赖节点自身的状态。（这个命令不能是心情好就攻击敌人，心情不好就原地休息。）

假设2的含义是：忠诚的将军需要判断接收到的命令是不是正确的。这个判断命令的方法是整个拜占庭容错技术的核心。


在1999年，著名的PBFT算法出现了。这个算法说起来也不难理解，他的核心思想是：对于每一个收到命令的将军，都要去询问其他人，他们收到的命令是什么。一个叛徒可以迷惑两个忠诚的将军。在使用不可伪造的书面信息时，在任何数量的将军和可能的叛徒的情况下这个问题都可以解决。


将军们必须有一个算法来保证：

A.所有忠诚的将军们决定行动计划。

忠诚的将军都会按照算法表达的他们应该做的去做，但是叛徒可以做他们想做的任何事。不管叛徒做什么，算法必须保证条件A。

B.少数叛徒不能使忠诚的将军采取一个坏计划。

PBFT算法的运作步骤为：

(1)取一个副本作为主节点，其他的副本作为备份；

(2)用户端向主节点发送使用服务操作的请求；

(3)主节点通过广播将请求发送给其他副本；

(4)所有副本执行请求并将结果发回用户端；

(5) 用户端需要等待F+1个不同副本节点发回相同的结果，作为整个操作的最终结果。

任何区块链子系统都可以出错代表什么意义？表示通讯子系统可能出错，计算子系统可能出错，投票的时候可以出错，每一步区块链投票都可以出错，数据库可以出错，并行算法可以出错，加解密可以出错。区块链每个功能、每个协议、每一步、每个节点都可以出错。而且出错不一定是“停止错误”，而且可能是“拜占庭错误”，就是有人故意捣蛋，送不同数据给不同节点。所以一个容错的区块链系统是非常复杂的！
