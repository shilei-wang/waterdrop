
=============================================
service
=============================================
【正向测试】 验证"define"交易功能是否正确。
【测试方法】 执行"define"交易。
【期望结果】 交易成功，并返回 "code:0"， 通过"query definition"查询， 确认service被正确define。


【正向测试】 验证"query schema"查询功能是否正确。
【测试方法】 执行"query schema"查询， 分别指定"pricing"和"result"参数。
【期望结果】 查询成功，并返回相应的schema格式。


【正向测试】 验证"bind"交易功能是否正确。
【测试方法】 先执行"define"交易，再执行"bind"交易
【期望结果】 交易成功，并返回 "code:0"， 通过"query binding"查询， 确认service被正确bind。


【正向测试】 验证"query binding"查询功能是否正确。
【测试方法】 先执行"define/bind"交易，再执行"query binding"查询
【期望结果】 查询成功， 确认service_name provider owner等信息和bind时一致。


【正向测试】 验证"query bindings"查询功能是否正确。
【测试方法】 先执行"define/bind"交易，再执行"query bindings"查询
【期望结果】 查询成功， 确认service_name provider owner等信息和bind时一致。


【正向测试】 验证"update-binding"交易功能是否正确。
【测试方法】 先执行"define/bind"交易， 再执行"update-binding"交易， 并且指定修改qos，并且增加amount抵押
【期望结果】 交易成功，并返回 "code:0"， 通过"query binding"查询， 确认qos被修改，且抵押的amount被增加。


【正向测试】 验证"set-withdraw-addr"交易功能是否正确。
【测试方法】 执行"set-withdraw-addr"交易， 并指定相应的地址。
【期望结果】 交易成功，并返回 "code:0"， 通过"query withdraw-addr"查询， 确认withdraw-addr被修改成新的地址。


【正向测试】 验证"enable"交易功能是否正确。
【测试方法】 先执行"define/bind"交易，再对该服务执行"enable"交易。
【期望结果】 交易成功，并返回 "code:0"， 通过"query binding"查询， 确认该服务被enable。


【正向测试】 验证"disable"交易功能是否正确。
【测试方法】 先执行"define/bind/enable"交易，再对该服务执行"disable"交易。
【期望结果】 交易成功，并返回 "code:0"， 通过"query binding"查询， 确认该服务被disable。


【正向测试】 验证"call"交易功能是否正确。
【测试方法】 先执行"define/bind"交易，再对该服务执行"call"交易。
【期望结果】 交易成功，并返回 "code:0"， 通过"query requests"查询， 确认该服务正确的call。


【正向测试】 验证"respond"交易功能是否正确。
【测试方法】 先执行"define/bind/call"交易，通过记录返回的id，再执行"respond"交易。
【期望结果】 交易成功，并返回 "code:0"， 通过"query response"查询， 确认该服务被正确的respond。


【正向测试】 验证"withdraw-fees"交易功能是否正确。
【测试方法】 先执行"define/bind/call/respond"交易，再执行"withdraw-fees"交易。
【期望结果】 交易成功，并返回 "code:0"， 通过通过查询余额的变化，确认fee被正确withdraw。


【负向测试】 "define"交易，define时指定一个错误的"name"
【测试方法】 执行"define"交易，并指定name为"0a"
【期望结果】 交易失败，并返回"must contain alphanumeric characters"信息。


【负向测试】 "define"交易，define时指定一个长度超过边界的"name"
【测试方法】 执行"define"交易，并指定name为"a1234567890123456789012345678901234567890123456789012345678901234567890"
【期望结果】 交易失败，并返回"length greater than 0 and less than or equal to 70"信息。


【负向测试】 "define"交易，define时指定重复的tag
【测试方法】 执行"define"交易，并指定tag为"t1,t1"
【期望结果】 交易失败，并返回"duplicate tag"信息。


【负向测试】 "define"交易，define时指定空的tag
【测试方法】 执行"define"交易，并指定tag为",t1"
【期望结果】 交易失败，并返回"tag must not be empty"信息。


【负向测试】 "define"交易，define时指定长度超出边界的tag
【测试方法】 执行"define"交易，并指定tag为"a1234567890123456789012345678901234567890123456789012345678901234567890"
【期望结果】 交易失败，并返回"max: 70: invalid tags"信息。


【负向测试】 "query definition"查询，查询一个不存在的definition
【测试方法】 执行"query definition"查询，指定一个不存在的definition name
【期望结果】 查询失败，并返回"unknown service definition"信息。


【负向测试】 "query definition"查询，查询一个name为空的definition
【测试方法】 执行"query definition"查询，指定name为空
【期望结果】 查询失败，并返回"invalid service name"信息。


【负向测试】 "query definition"查询，查询一个name为空的definition
【测试方法】 执行"query definition"查询，指定name为空
【期望结果】 查询失败，并返回"invalid service name"信息。


【负向测试】 "query schema"查询，查询一个错误的type
【测试方法】 执行"query definition"查询，指定type为"abc"
【期望结果】 查询失败，并返回"invalid service schema name"信息。





=============================================
guardian
=============================================
【正向测试】 验证"add-profiler"交易功能是否正确。
【测试方法】 执行"add-profiler"交易。
【期望结果】 交易成功，并返回 "code:0"，通过profiler查询功能，确认新的profiler被添加。


【正向测试】 验证"delete-profiler"交易功能是否正确。
【测试方法】 先执行"add-profiler"交易， 然后执行"delete-profiler"交易。
【期望结果】 交易成功，并返回 "code:0"，通过profiler查询功能，确认新的profiler被删除。


【正向测试】 验证"query profilers"查询功能是否正确
【测试方法】 执行"query profilers"查询。
【期望结果】 查询成功，并返回相应的profilers列表信息。


【负向测试】 "add-profiler"交易，添加一个已经存在的profiler
【测试方法】 先执行"add-profiler"交易，先执行"add-profiler"交易 add同样的地址。
【期望结果】 交易失败，并返回"profiler already exists"信息。


【负向测试】 "add-profiler"交易，添加一个错误的地址
【测试方法】 执行"add-profiler"交易，并指定add一个错误的地址
【期望结果】 交易失败，并返回"pchecksum failed"信息。


【负向测试】 "add-profiler"交易，添加一个错误的地址
【测试方法】 执行"add-profiler"交易，并指定add一个错误的地址
【期望结果】 交易失败，并返回"pchecksum failed"信息。


【负向测试】 "delete-profiler"交易，删除一个不存在的profiler
【测试方法】 执行"delete-profiler"交易，并指定一个并不是profiler的地址
【期望结果】 交易失败，并返回"unknown profiler"信息。



=============================================
htlc
=============================================
【正向测试】 验证"create"交易功能是否正确， 指定timestamp。
【测试方法】 生成随机secret，timestamp，并计算出hashlock。指定以上参数并执行"create"交易，指定相应的amount，并记录交易前后的账户余额。
【期望结果】 交易成功，并返回 "code:0"，htlc被正确create。 交易前后账户差额为amount+fee。


【正向测试】 验证"create"交易功能是否正确， 不指定timestamp， 客户端自己计算返回secret
【测试方法】 执行"create"交易，指定相应的amount，并记录交易前后的账户余额。
【期望结果】 交易成功，并返回 "code:0"，htlc被正确create。 交易前后账户差额为amount+fee。


【正向测试】 验证"query htlc"查询功能是否正确
【测试方法】 执行"create"交易，执行"query htlc"查询命令
【期望结果】 查询成功，并返回相应的htlc信息。


【正向测试】 验证"claim"查询功能是否正确
【测试方法】 执行"create"交易，记录create时指定的amount， 执行"claim"交易， 记录claim对象在交易前后的余额。
【期望结果】 交易成功，并返回 "code:0"，htlc被正确claim。 claim对象在交易前后账户差额为amount。


【负向测试】 "create"交易， 指定amount为错误的数量
【测试方法】 执行"create"交易，并指定amount分别为"0uiris"和"-1uiris"
【期望结果】 交易失败，并返回"the transferred amount must be valid"和"invalid coin expression"信息。


【负向测试】 "create"交易， 指定amount超过余额上限
【测试方法】 执行"create"交易，并指定amount分别为"10000000000000000000000000000000iris"
【期望结果】 交易失败，并返回"insufficient funds"信息。


【负向测试】 "create"交易， 指定错误的secret
【测试方法】 执行"create"交易，并指定格式错误的secret
【期望结果】 交易失败，并返回"encoding/hex: odd length hex string"信息。


【负向测试】 "create"交易， 指定time_lock超出边界
【测试方法】 执行"create"交易，并指定time_lock分别为"0"和"30000"
【期望结果】 交易失败，并返回"the time lock must be between [50,25480]: invalid time lock"信息。


【负向测试】 "create"交易， 指定错误的timestamp
【测试方法】 执行"create"交易，并指定格式错误的timestamp
【期望结果】 交易失败，并返回"invalid syntax"信息。


【负向测试】 "query htlc"查询，查询一个不存在的hashlock
【测试方法】 执行"query htlc"查询，指定一个不存在的hashlock
【期望结果】 查询失败，并返回"key not found"信息。


【负向测试】 "query htlc"查询，指定hashlock为空
【测试方法】 执行"query htlc"查询，指定一个空的hashlock
【期望结果】 查询失败，并返回"HTLC  not found"信息。


【负向测试】 "claim"交易，claim一个并未create的htlc
【测试方法】 执行"query htlc"查询，指定一个并未create的hashlock
【期望结果】 查询失败，并返回"unknown htlc"信息。


【负向测试】 "claim"交易，claim时使用错误的secret
【测试方法】 执行"create"交易，执行"claim"交易，指定一个错误的secret
【期望结果】 查询失败，并返回"invalid secret"信息。



=============================================
nft
=============================================
【正向测试】 验证"issue"交易功能是否正确
【测试方法】 执行"issue"交易，并指定denomID。
【期望结果】 交易成功，并返回 "code:0"，nft被正确issue。


【正向测试】 验证"mint"交易功能是否正确
【测试方法】 先进行"issue"操作，再执行"mint"交易（指定刚才issue出的denomID， 和新的tokenID）。
【期望结果】 交易成功，并返回 "code:0"。 nft被正确mint


【正向测试】 验证"transfer"交易功能是否正确
【测试方法】 先进行"issue/mint"操作，执行"transfer"交易
【期望结果】 交易成功，并返回 "code:0"。 查询和新的tokenID的信息， tokenID被正确转到新的用户。


【正向测试】 验证"edit"交易功能是否正确
【测试方法】 先进行"issue/mint"操作，执行在"edit"交易并指定uri和data分别为"tokenURI-2","tokenData-2"
【期望结果】 交易成功，并返回 "code:0"。 查询tokenID的信息，， 相对应的字段被正确修改。


【正向测试】 验证"query Supply"查询功能是否正确
【测试方法】 先进行"issue/mint"操作，执行"query Supply"查询命令
【期望结果】 查询成功，并返回相应的Supply信息。

【正向测试】 验证"query Owner"查询功能是否正确
【测试方法】 先进行"issue/mint"操作，执行"query Owner"查询命令
【期望结果】 查询成功，并返回相应的Owner信息。

【正向测试】 验证"query Collection"查询功能是否正确
【测试方法】 先进行"issue/mint"操作，执行"query Collection"查询命令
【期望结果】 查询成功，并返回相应的demon信息。


【正向测试】 验证"query Denoms"查询功能是否正确
【测试方法】 先进行"issue/mint"操作，执行"query Denoms"查询命令
【期望结果】 查询成功，并返回相应的demons信息。


【正向测试】 验证"query Token"查询功能是否正确
【测试方法】 先进行"issue/mint"操作，执行"query Token"查询命令
【期望结果】 查询成功，并返回相应的Token信息。


【负向测试】 "issue"交易， 指定长度超过边界的name
【测试方法】 执行"issue"交易，并且指定name为"a"和"1234567890123456789012345678901234567890123456789012345678901234567890"
【期望结果】 交易失败，并返回"only accepts value [3, 64]"信息。


【负向测试】 "issue"交易， 重复issue相同symbol
【测试方法】 执行"issue"交易，并且用上次的symbol再次issue。
【期望结果】 交易失败，并返回"already exists"信息。


【负向测试】 "issue"交易， 重复issue相同name
【测试方法】 执行"issue"交易，并且用上次的name再次issue。
【期望结果】 交易失败，并返回"already exists"信息。


【负向测试】 "mint"交易， mint一个不存在的symbol
【测试方法】 执行"mint"交易，并且指定symbol为"abcd"
【期望结果】 交易失败，并返回"not exists: invalid denom"信息。


【负向测试】 "mint"交易， mint重复的tokenID
【测试方法】 执行"issue"交易，执行"mint"交易，再次执行"mint"交易并指定重复的tokenID
【期望结果】 交易失败，并返回"NFT already exists"信息。


【负向测试】 "transfer"交易， transfer时指定错误的denom
【测试方法】 执行"issue"交易，再次执行"transfer"交易并指定denom为"aaaaa"
【期望结果】 交易失败，并返回"not exists: invalid denom"信息。


【负向测试】 "transfer"交易， transfer时指定错误的tokenID
【测试方法】 执行"issue"交易，再次执行"transfer"交易并指定tokenID为"aaaaa"
【期望结果】 交易失败，并返回"unknown NFT collection"信息。


【负向测试】 "transfer"交易， transfer owner已经不是自己的tokenID
【测试方法】 执行"issue/transfer"交易，再次执行transfer交易（此时owner已经不属于自己）
【期望结果】 交易失败，并返回"unauthorized address"信息。


【负向测试】 "edit"交易， edit时指定错误的denom
【测试方法】 执行"issue"交易，再次执行"edit"交易并指定denom为"abc"
【期望结果】 交易失败，并返回"not exists: invalid denom"信息。


【负向测试】 "edit"交易， edit不属于自己的tokenID
【测试方法】 执行"issue/transfer"交易，再次执行"edit"交易。
【期望结果】 交易失败，并返回"unauthorized address"信息。


【负向测试】 "edit"交易， edit不属于自己的tokenID
【测试方法】 执行"issue/transfer"交易，再次执行"edit"交易。
【期望结果】 交易失败，并返回"unauthorized address"信息。


【负向测试】 "query Supply"查询，查询一个不存在的demon
【测试方法】 执行"query Supply"查询，指定一个不存在的demon
【期望结果】 交易失败，并返回"amount:0"信息。


【负向测试】 "query Owner"查询，查询一个不存在的Owner地址
【测试方法】 执行"query Owner"查询，指定一个不存在的Owner地址
【期望结果】 交易失败，并返回"id_collections:[]"信息。


【负向测试】 "query Collection"查询，查询一个不存在的demon
【测试方法】 执行"query Collection"查询，指定一个不存在的demon
【期望结果】 交易失败，并返回"not existed : invalid denom"信息。

【负向测试】 "query Token"查询，查询一个不存在的demon
【测试方法】 执行"query Token"查询，指定一个不存在的demon
【期望结果】 交易失败，并返回"unknown NFT: invalid request"信息。


【负向测试】 "query Token"查询，查询一个不存在的TokenID
【测试方法】 执行"issue"交易，执行"query Token"查询，指定一个不存在的TokenID
【期望结果】 交易失败，并返回"unknown NFT: invalid request"信息。

=============================================
token
=============================================
【正向测试】 验证"issue"交易功能是否正确
【测试方法】 在"issue"交易前查询账户余额，执行"issue"交易，再次查询账户余额。 对新issue的token，进行转账交易。
【期望结果】 交易成功，并返回 "code:0"。 两次账户余额的差值等于issue的花费加上fee的值， 查询的账户增加相对的新token数量，新issue的token可以正常进行send交易。

【正向测试】 验证"mint"交易功能是否正确
【测试方法】 先进行"issue"操作，在"mint"交易前查询账户余额，执行"mint"交易，再次查询账户余额。
【期望结果】 交易成功，并返回 "code:0"。 两次账户余额的差值等于"mint"的花费加上fee的值。 查询的账户增加相对于的mint数量的token。


【正向测试】 验证"edit"交易功能是否正确
【测试方法】 先进行"issue"操作，执行在"edit"交易时修改"name/mintable/maxsupply"等字段。
【期望结果】 交易成功，并返回 "code:0"。 查询token的信息， 相对应的字段被正确修改。


【正向测试】 验证"transfer"交易功能是否正确
【测试方法】 先进行"issue"操作，执行在"transfer"交易，把token owner转给其他人。
【期望结果】 交易成功，并返回 "code:0"。 查询token的信息， "token owner"被正确转到新的用户。


【正向测试】 验证"query token"查询功能是否正确
【测试方法】 执行"query token"查询命令。（包含子命令query token token和 query token tokens）
【期望结果】 查询成功，并返回相应的token、tokens信息。


【正向测试】 验证"query token"查询功能是否正确
【测试方法】 执行"query token"查询命令。（包含子命令query token token和 query token tokens）
【期望结果】 查询成功，并返回相应的token、tokens信息。


【正向测试】 验证"query fee"查询功能是否正确
【测试方法】 执行"query fee"查询命令。
【期望结果】 查询成功，并返回相应的issue_fee和mint_fee所需要的费用。


【负向测试】 "issue"交易， 指定错误的scale
【测试方法】 执行"issue"交易，并且指定scale为"-1"和"10"
【期望结果】 交易失败，并返回"invalid argument"和 "invalid token scale"信息。

【负向测试】 "issue"交易， 指定错误的initialSupply
【测试方法】 执行"issue"交易，并且指定initialSupply为"-1"和"abc"
【期望结果】 交易失败，并返回"invalid argument"信息。

【负向测试】 "issue"交易， 指定的超出边界的initialSupply
【测试方法】 执行"issue"交易，并且指定initialSupply为"2000000000000000000"
【期望结果】 交易失败，并返回"invalid token initial supply"信息。

【负向测试】 "issue"交易， 指定initialSupply大于maxSupply
【测试方法】 执行"issue"交易，并且指定initialSupply，maxSupply分别为20000， 10000
【期望结果】 交易失败，并返回"invalid token max supply"信息。

【负向测试】 "issue"交易， 指定错误的name
【测试方法】 执行"issue"交易，并且指定name分别为a，12a
【期望结果】 交易失败，并返回"only accepts length"和"only accepts alphanumeric characters"信息。

【负向测试】 "issue"交易， 重复issue同一个symbol的token
【测试方法】 执行"issue"交易，并且用刚才issue的symbol再次重复issue
【期望结果】 交易失败，并返回"symbol already exists"信息。


【负向测试】 "mint"交易， mint一个不可增发的token
【测试方法】 执行"issue"交易，并且指定mintable=false， 对该token进行mint操作
【期望结果】 交易失败，并返回"set to be non-mintable"信息。


【负向测试】 "mint"交易， 增发超出maxsupply的token
【测试方法】 执行"issue"交易，并且指定maxSupply=20000， 对该token进行mint操作，增发数量指定为100000
【期望结果】 交易失败，并返回"exceeded the maximum supply"信息。


【负向测试】 "edit"交易， 编辑一个并未issue的token
【测试方法】 执行"edit"交易，并且指定一个不存在的token。
【期望结果】 交易失败，并返回"token does not exist"信息。


【负向测试】 "edit"交易， 使得maxSupply小于initialSupply
【测试方法】 执行"issue"交易(指定initialSupply=10000)，执行"edit"交易并且指定maxSupply=9999
【期望结果】 交易失败，并返回"invalid token max supply"信息。


【负向测试】 "edit"交易， 指定错误的maxSupply
【测试方法】 执行"issue"交易，执行"edit"交易并且指定maxSupply分别为"2000000000000000000"和"-1"
【期望结果】 交易失败，并返回"invalid token max supply"和"invalid argument"信息。


【负向测试】 "transfer"交易， 把token自己transfer给自己
【测试方法】 执行"issue"交易， 然后把该token的转移给自己
【期望结果】 交易失败，并返回"the new owner must not be same"信息。


【负向测试】 "transfer"交易， 转移一个owner已经不是自己的token
【测试方法】 执行"issue"交易， 然后把该token的转移给他人， 再次把该token转移给他人、
【期望结果】 交易失败，并返回"invalid token owner"信息。


【负向测试】 "transfer"交易， 转移一个不存在的token
【测试方法】 执行"transfer"交易，指定一个不存在的token
【期望结果】 交易失败，并返回"token does not exist"信息。


【负向测试】 "query Token"查询，查询一个不存在的token
【测试方法】 执行"query Token"查询，指定一个不存在的token
【期望结果】 交易失败，并返回"token not found"信息。


【负向测试】 "query fee"查询，查询name长度超过边界值的fee
【测试方法】 执行"query fee"查询，指定name分别为"a0"和"a022222213321234342523445235"
【期望结果】 交易失败，并返回"only accepts length [3, 20]"信息。


【负向测试】 "query fee"查询，查询name不符合规范的fee
【测试方法】 执行"query fee"查询，指定name分别为"0222a"
【期望结果】 交易失败，并返回"only accepts alphanumeric characters"信息。



=============================================
bank
=============================================
【正向测试】 验证"send"交易功能是否正确
【测试方法】 在转账前查询账户余额，执行转账，转账后再次查询账户余额
【期望结果】 交易成功，并返回 "code:0"。 两次账户余额的差值等于转账金额加上fee的值。


【正向测试】 验证"balances"查询功能是否正确
【测试方法】 在"send"的测试流程中加入了"balances"的查询余额的命令
【期望结果】 查询成功，并返回相应的余额。


【正向测试】 验证"account"查询功能是否正确
【测试方法】 执行"account"查询命令。
【期望结果】 查询成功，并返回相应的账户信息。


【负向测试】 "send"交易， 转账"0"token
【测试方法】 执行"send"交易，并且指定转账金额为"0"token
【期望结果】 交易失败，并返回相应"Error"信息。


【负向测试】 "send"交易， 转账"9999999999999999999999999999"token
【测试方法】 执行"send"交易，并且指定转账金额为"9999999999999999999999999999"token
【期望结果】 交易失败，并返回 "insufficient funds"信息。


【负向测试】 "send"交易， 转账"1abc"
【测试方法】 执行"send"交易，并且指定转账金额为"1abc"
【期望结果】 交易失败，并返回 "insufficient funds"信息。


【负向测试】 "account"查询， 查询一个在链上不存在的地址的信息
【测试方法】 执行"account"查询，查询链上不存在的地址
【期望结果】 交易失败，并返回相应"Error"信息。


【负向测试】 "balances"查询， 查询一个在链上不存在的地址的余额
【测试方法】 执行"balances"查询，查询链上不存在的地址
【期望结果】 交易失败，并返回相应"Error"信息。




